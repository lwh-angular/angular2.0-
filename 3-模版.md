	•	NG-2 表单
表单在我们的web应用中是至关重要的，表面上看，表单最直截了当的就是用户输入数据，点击提交这么简单。但事实上，表单所呈现的形式是非常复杂多变的，比如我们angular表单可以实现用户控制，监视变化，验证输入、错误信息处理和数据绑定等功能。
本节将详细介绍angular2表单，主要是从技巧方面来认识表单在angular2中带给用户的良好体验，具体如下：
	•	通过组件和模板来创建一个表单；
	•	通过ngModel双向数据绑定的例子来了解如何在input中读写值；
	•	angular2相关表单指令的运用，如NgForm、NgForm、NgForm、NgForm和NgCongrolGroup等；
	•	表单局部变量的运用；
	•	表单错误信息和处理或者Validators验证处理等。
	•	1.表单组件类和表单模板
angular2表单是基于HTML的模板及其控制该模板数据以及用户交互的组件组成，我们需要引入一个Componet，这意味着可以在该组件中定义选择器和模板或者引入一个外链的html模板。接下来定义一个组件类，其作用是控制表单相关属性的表现，定义表单方法等。
如下面的例子：【暂时用官网的例子。TODO...】
import {Compontent} from ‘angular2/core’; import {NgForm} from ‘angular2/common’; import {Hero} from ‘./hero’; @Component ({ selector: ‘hero-form’, templateUrl: ‘app/hero-form.compontent.html }) export class HeroFormCompent { powers = [‘ReallySmart’,’Super Flexible’,’Super Hot’,’Weather Changer’]; model=new Hero(18,’DrIQ’,this.powers[0],’Chuck Overstreet’); submitted = false; onSubmitt(){this.submitted= true;}
在这个例子中，在引入的Component中，需要定义一个selector选择器，这表示我们能够在父模板中插入该表单。同样的，模板可以是外链URL模板也可以直接包裹在template键对应的值中。如：
template: `<form #f="ngForm" (submit)="search(f.value)"> <select> <option value="web">网页</option> <option value="news">新闻</option> <option value="image">图片</option> </select> <input type="text" ngControl="kw"> <button type="submit">搜索</button> </form>`
而控制表单的属性或者用户行为等，我们将定义一个类来处理，如HeroFormCompent类，我们定义了相关的属性，提交数据方法等。
2.表单指令
2.1 NgForm
NgForm指令为表单建立一个控件组对象，它包含当前选择器所在的form标签，关于NgForm请看下面的例子：
import {Component} from "angular2/core"; import {bootstrap} from "angular2/platform/browser"; import {CORE_DIRECTIVES,FORM_DIRECTIVES} from "angular2/common"; //组件 @Component({ selector:"xx-app", directives:[FORM_DIRECTIVES,CORE_DIRECTIVES], template:` <form #f="ngForm" <input type="text" ngControl="title"> (ngSubmit)="onSubmit(f.value)" </form> ` })
2.1.1 指令依赖声明
NgForm指令包含在预定义的数组变量FORMDIRECTIVES中，所以我们要在组件注解的directives属性中优先声明FORMDIRECTIVES，这样就可以直接使用NgForm指令了。
2.1.2 局部变量
通过使用“#”符号，我们可以创建一个引用控件组对象的局部变量，如上例中的变量f，这个变量它的value属性是一个JSON对象，该对象的键对应的是表单中input元素的ng-control属性，值对应的是input元素的值。接下来我们介绍NgControl。
2.2.NgControl
2.2.1 NgControl的运用
我们可以在input标签中添加ngControl属性，NgControl将创建一个新的Control并动态的将它添加到父ControlGroup中，同时绑定一个DOM元素到这个新的Control，这就将这个input标签和Control联系起来了，我们访问该标签将直接通过这个ngControl的属性值来访问。
需要注意的是，ngControl必须是作为一个NgForm或者NgFormModel的后代来使用，否则将会报错，因为这个指令需要将创建的控件对象添加到祖先（NgForm或者NgFormModel）所创建的控件中。
在这里，值得一提的是NgControlNmae，它的选择符是[ngControl]，这就意味着，你必须和ngControl来搭配使用，这个指令才会发挥它的作用。NgControlName指令为宿主DOM对象创建一个控件对象，并将这个对象以ngControl属性指定的名称绑定到DOM对象上，举个例子，如我们最常用的用户名和密码表单：
<form #f="ngForm"> <input class="user-name" type="text" ngControl="user"> <input class="password" type="password" ngControl="password"> </form>
我们创建了两个Control对象，NgControlName指令为宿主DOM对象创建两个控件对象，然后将ngControl属性指定的名称user、password绑定到了其对应的input标签对应的DOM数上。这样的好处是我们可以很方便的通过控件组获取对应的值，也能实现ngModel模型与表单的双向绑定，下一节我们将介绍NgModel。
2.2.2 ngControl监视状态
表单不仅仅是数据的绑定，同样的，我们也希望能够监测到表单的状态，NgControl指令能够保持对状态的监视，除此之外，它会在这下面的三个状态值中影响着当前表单的控制器。
	•	状态

	•	True

	•	False

	•	control是否被访问

	•	ng-touched

	•	ng-untouched

	•	control是否发生了变化

	•	ng-dirty

	•	ng-pristine

	•	control是否合法有效

	•	ng-valid

	•	ng-invalid

	•
通过监测NgControl状态的改变，我们能设置我们想要的特殊css类来更新控制器，比如能够通过监视状态合法性的属性ng-valid和ng-invalid来改变控制器是否需要弹出或者显示输入非法的状态提醒，如显示、隐藏错误信息等。我们能瞬间探测到这些状态的改变，同时我们可以马上为我们的表单组件添加对应的处理。以下是对这些状态使用的一些例子：
// todo ... 
2.3 NgModel
2.3.1 NgModel的运用
在表单中，我们常常需要用到这样的场景，在model数据结构有变化的时候，我们希望能够及时的反应在表单中，同样的，我们在操作表单的时候，也是需要表单的变化需要实时的在model中有响应的。也就是说，我们需要同一时间去显示、监听和摘录数据。
angular2采用的是ngModel来实现数据的双向绑定的，NgModel指令可以令表单和模型（model）的数据绑定超级简单，它的语法是：[(ngModel)]=“...”，例子如下。
<input type=”text” class=”form-controt” required [(ngModel)]=”model.name”> TODO:监视这个表单的值：{{model.name}}
2.3.2 NgModel双向绑定原理
在模板语法里，我们已经了解过了属性绑定和事件绑定，在属性绑定里，值产生于模型赋值给目标属性，通过中括号-[]来包裹这个属性，那么我们的模型也将通过这个中括号内的属性值来辨识这个目标属性。这是一种由模型向视图的单项数据绑定。而事件绑定则相反，在事件绑定中，目标属性对应表单的变化的值将赋予给模型，通过小括号-()来包裹这个属性，这个包裹的属性将会标识模型中对应该目标属性名的变化。这是一种反向的视图向模型的单向数据绑定。这就是[()]实现数据双向绑定的方式，很好的预示将要发生什么。
如上面的例子，我们可以改写成这样：
<input type=”text” class=”form-control” required [ngModel]=”model.name” (ngModelChange)=”model.name=$event”> TODO:监视这个表单的值： {{model.name}}
该表单中，模板表达式：model.name=$event是被用来发现来自于DOM事件的$event事件，ngModelChange不是一个input元素事件，本身不会产生一个DOM事件，实际上它是NgModel指令的一个事件属性，它是能够返回输入框的一种angular的EventEmitter属性，这种属性能够精确的捕获我们分配给模型“anyName”属性的值。在angular2表单中，我们看到[(anyName)]时，它预示着这个anyName指令将拥有一个该属性的输入值和一个对应着anyName-change的输出值。
2.4 NgSumit
用户填完表单之后，我们需要获取表单的完整数据以便提交。通常我们会在表单的底部添加一个提交按钮并设置其type的值等于submit，按钮本身不做任何事情但是却能监听表单的提交这个动作，但是此刻的提交没什么作用，为此，angular2提供了一个NgSubmit指令于form标签，这样我们就可以绑定事件到模型的submit方法上用来出来表单的提交了。例子如下：
import { Component } from 'angular2/core'; import { FORM_DIRECTIVES } from 'angular2/common'; @Component({ selector: 'demo-form', directives: [FORM_DIRECTIVES], template: ` <form #f="ngForm" (ngSubmit)="onSubmit(f.value)"> <input type="text" ngControl="sku"> <button type="submit" class="button">Submit</button> </form> ` }) export class DemoForm { onSubmit(value: string): void { console.log('you submitted value: ', value); } }
该例子中，我们定义了一个模板局部变量#f，并用NgForm指令来初始化它的值，这样我们就能通过submit来获取该表单需要提交的数据结构了。
 
 
Angular2通过组件（Component）实例和模板（Template）之间的交互，来管理用户可见的内容。大多数人通过以前对MVC或MVVM的经验来熟悉组件和模板两者的相对关系，在Angular2中，组件担当了Controller/ViewModel的角色，而模板则代表了View层。
模板主要的形态是HTML，实际上HTML正是Angular模板的默认使用语言，绝大部分的HTML语法在模板中也都是适用的，除了\<script\>标签，\<script\>标签主要是为了防止Javascript脚本注入的可能性，另外像<html>、<body>、<base>这些标签虽然合法，但没有实际使用意义。除此之外，Angular2对HTML语法进行了扩展，可以编写组件和指令创建一个新的HTML元素或者DOM属性（组件我们在第二章已经学习了，指令的学习放在了第4章），也可通过各种类型的数据绑定动态变更HTML内容，如动态插值、属性绑定等，这些新扩展的语法正式本章将要重点讲述的内容。
3.1 插值
数据绑定最常见的形式就是插值，例如我们在jQuery模板里经常看到这样的插值代码：
<span>My name is <%=myName %></span>
<%=%>是作为输出变量值的语法，而在Angular2里面可以用双大括号来实现：
<span>My name is {{myName}}</span>
<img src="{{imgUrl}}" style="height:30px">
除此之外，插值还可以是其他合法的表达式：
<!-- "The sum of 1 + 1 is 2" -->
<p>The sum of 1 + 1 is {{1 + 1}}</p>
甚至可以调用宿主组件的函数：
<!-- "The sum of 1 + 1 is not 4" -->
<p>The sum of 1 + 1 is not {{1 + 1 + getVal()}}</p>
表面上看来插值的作用是把{{和}}中的内容计算转化成字符串后，”替换”{{...}}这个区块的内容，这样的理解在使用上并没有问题，实际上插值的本质是转化成『属性绑定』的一种特殊语法，我们会在『属性绑定』小节里详解。关于{{和}}里头的内容，在Angular2里称之为『模板表达式』，我们先继续深入了解什么是模板表达式。
3.1.1 模板表达式
模板表达式是Angular2模板里最先执行的，执行完会生成结果字符串，并赋值到绑定对象上。模板表达式和JavaScript语句类似，大部分JavaScript表达式同时也是合法的模板表达式，但仍有一些例外：
	•	不能进行赋值操作。
	•	操作符new是不被允许的。
	•	不支持位运算符（|和&）。
	•	不支持自增++和自减--运算符。
	•	模板表达式操作符，例如|和?.等，被赋予了新的含义。
	•	在模板表达式里，我们是不能引用到任何全局命名空间中的成员，如window和document，也无法调用console.log或是Math.min方法。所谓表达式上下文通常即是宿主组件的实例对象，我们绝大部分的数据源都放在这个实例对象上，如上例的myName和imgUrl是宿主组件的成员变量。除此之外，模板表达式还可以引用『本地模板变量』，我们将会在后面章节讲述到。
模板表达式可以直接影响到应用的稳定性，写得不好可导致应用崩溃。Angular2有自己的一套表达式编写规范。首先，模板表达式不能产生其他副作用，例如改变应用的状态，这个规范是基于Angular2的”单向数据流”准则；其次，模板表达式尽可能简单，不能有耗时操作。在Angualar2应用的运行过程中，键盘、鼠标事件都会触发表达式的执行，一个模板表达式可能会被执行很多次，如果模板表达式过于复杂，将会大大降低应用的使用体验。
Todo: Idempotence
3.1.2 模板声明
A template statement responds to an event raised by a binding target such as an element, component, or directive. 
模板声明是用来响应事件处理，出现在event关键字的右边
<button (event)="statement" >
跟模板表达式类似，模板声明和Javascript语句类似，但在Angular2里面，模板声明和模板表达式的解释器不是同一个，模板声明支持=赋值操作，也只是多条语句（使用分好;和`,``分隔）,但还是有些语句是不能使用的：
	•	new操作
	•	自增++和自减--操作
	•	像+=和-=的操作符赋值
	•	位操作符|和&
	•	模板表达式操作符（pipe和?.）
	•	模板声明的执行是有副作用的，会根据用户的输入变更应用的状态，要是不能变更的话事件执行就没有意义了。模板声明是单向数据流的一种，前面提到的模板表达的数据流向是数据源到模板，而模板声明多用于模板数据流向数据源。
和模板表达式一样，模板声明也不能引用任何全局对象，如window和document，同样也无法调用console.log或是Math.min。模板声明只能引用其上下文环境的成员变量，模板声明的上下文环境实际上跟模板表达式一致，例如(click)="onSave"里头的”onSave”函数肯定是宿主组件的实例函数。模板声明也还可以应用『本地模板变量』，最常见的就是保留字$event的引用，它是DOM事件本身的一个扩展引用。
另外，和模板表达式一样，模板声明尽可能不要写得太复杂，推荐的写法是一个简单的函数调用，或者是一次赋值操作。
到这里，我们已经对模板表达式和模板声明有一个大致的了解，除了插值操作，Angular2里还有很多各式各样的数据绑定语法，下一节详细讲解。
3.2 数据绑定
数据绑定是管理应用程序里的数值的一种机制，它可以让我们从HTML里取值和赋值，使得数据的读写，数据的持久化操作变得更加便捷，我们只根据语法编写的命令，其他的交给Angular2就可以了。 
Angular2提供了各式各样的数据绑定形式，根据数据的流向可把他们分成三种类型，每种类型都有它各自的语法。
	•	单向：数据源到目标视图

	•	{{expression}}
[target]=”expression”
bind-target=”expression”

	•	插值（Interpolation)
DOM属性(property）
HTML元素属性（Attribute）
类（Class）
样式（Style）

	•	单向：目标视图到数据源

	•	(target)=”expression”
on-target=”expression”

	•	事件（Event）

	•	双向

	•	[(target)]=”expression”
bindon-target=”expression”

	•	双向

	•	数据流向

	•	语法

	•	绑定类型

	•
Todo need html plus description 
除了插值，其他绑定类型都有绑定目标，使用[]或()包含或者在前面用bind-、on-或bingon-标志。那什么是绑定目标，让我们先来了解一种HTML的假想模型。 
Angular2模板扩展了HTML元素标签类型，或者我们成为HTML+，所以跟我们平时用的HTML代码是不一样的，先看下面一段普通HTML代码，当我们去修饰HTML元素时是利用字符串常量去赋值元素属性。
先举一个很常见数据绑定例子：
<!-- 绑定disable状态值由`isUnchanged`控制 -->
<button [disabled]="isUnchanged">Save</button>
观察这行代码，直觉会告诉我们，我们绑定了button的disabled属性，并且通过宿主组件的isUnchanged成员变量去设置disabled属性的值。但其实这种直觉是错误的，我们平时接触到的HTML表现模型误导了我们。事实上，一旦我们开始了数据绑定，我们就不再是操作HTML元素的属性，而是操作DOM对象、组件以及指令的对象成员变量。
理解HTML元素属性和DOM对象属性的区别是理解Angular2如何进行数据绑定的关键。HTML元素属性是在HTML里定义的，DOM对象属性是在DOM（文档对象模型）里定义的，一些HTML元素属性和DOM对象属性有相同的名字且一一对应（如id属性），有些HTML元素属性并没有对应的DOM对象属性（如colspan），也一些DOM对象属性没有对应的HTML元素属性（如textContent），更有一些HTML元素属性表面看起来是对应DOM对象属性，但实际并不是的。
HTML元素属性的作用是用来初始化DOM对象属性，建立完DOM树后，HTML元素属性的使命就结束了，但DOM对象属性会被改变。
举个例子，当浏览器渲染<input type="text" value="Bob">时，浏览器会创建一个对应的DOM节点并初始化值为”Bob”。当用户在该输入框里输入”Sally”，DOM对象属性值就变成”Sally”，但HTML元素属性值依然是”Bob”（可通过input.getAttribute('value')来获取）。所以HTML元素属性值是指定初始化的值，DOM对象属性值当前值
再举个例子，对于disabled属性，HTML元素属性和DOM对象属性都有定义，在DOM对象属性disabled属性默认值为false所以button默认为可点击状态，当HTML元素属性值改为disabled时，button为禁用状态。通过添加和移除HTML里的disabled属性可使得button状态变更，但若想通过设置false值来使得禁用态失效，是不会生效的，<button disabled="false">Still Disabled</button>依然为禁用状态，所以即使HTML元素属性和DOM对象属性定义的名字一样，他们并不是同一个东西。
需要强调的一点是，数据绑定是作用在DOM对象属性，而不是HTML元素属性。HTML元素属性的唯一作用就是用来初始化DOM对象的值或是指令（第四章详解）的值。
根据绑定类型的不同，数据绑定的目标可以是一个（DOM元素 | 组件 | 指令）的对象属性，也可以是一个（DOM元素 | 组件 | 指令）的事件，甚至（极少见到）是元素的属性名。总结见下表：
	•	属性（Property）

	•	DOM属性
组件属性
指令属性

	•	<img [src]="heroImageUrl">
<hero-detail [hero]="currentHero">
</hero-detail>

	•	事件

	•	DOM事件
组件事件
指令事件

	•	<button (click)="onSave()">Save</button>
<hero-detail (deleted)="onHeroDeleted()">
<hero-detail>
<div myClick (myClick)="clicked=$event">
click me</div>

	•	双向

	•	指令事件
DOM属性

	•	<input [(ngModel)]=“heroName”>

	•	HTML元素属性

	•	HTML元素属性（特例）

	•	<button [attr.aria-label]="help">
help</button>

	•	类

	•	类属性

	•	<div [class.special]="isSpecial">
Special</div>

	•	样式

	•	样式属性

	•	<button [style.color]="isSpecial?'red':'green'">

	•	绑定类型

	•	目标

	•	举例

	•
 
3.2.1 属性绑定
当我们希望将HTML元素的属性设置为模板表达式的值时，就需要使用属性绑定了，这里的属性是指DOM对象、组件或指令的属性。最常见的属性绑定就是设置HTML元素属性为组件的属性值。例如我们为image元素设置source属性为组件的heroImageUrl属性时，就可以采用如下的属性绑定方法：
<img [src]="heroImageUrl">
另一个例子是控制button是否为可点击状态：
<button [disabled]="isUnchanged">Cancel is disabled</button>
还可以设置指令的属性：
<div [ngClass]="special">NgClass is special</div>
又或者设置自定义组件的属性（这是父子组件通讯的一个好方法）：
<hero-detail [hero]="selectedHero"></hero-detail>
3.2.1.1 单向数据流
属性绑定是一种单向数据绑定，意思是指数据的流向是单向地从组件数据源到目标元素属性，而不能获取目标元素的属性值。我们也不能使用属性绑定去调用函数的执行，如果DOM对象触发了一个事件，我们可以用事件绑定来（后面会讲到）处理。如果真的需要读取目标元素属性或者调用它的函数，需要用到另一种不同的技术，参考viewChild和contentChild。
Todo viewChild contentChild
3.2.1.2 绑定目标
现在我们把注意力集中在[src]里，中括号内的src成为绑定目标，标记绑定目标除了可以使用中括号[]外，还可以使用bind-前缀，如：
<img bind-src="heroImageUrl">
通常情况下目标的名称就是DOM对象属性的名称。如上面例子中的src，并不是HTML元素的属性名，而是image元素（DOM元素）属性名。DOM 
元素属性是最常见的绑定目标，不过Angular会首先判断目标名称是否是一个定义好的指令的属性名，也就是说指令属性处理的优先级大于DOM元素属性。如下所示：
<div [ngClass]="classes">[ngClass] binding to the classes property</div>
3.2.1.3 避免副作用
模板表达式写得好不好，首要看它执行完后有没有造成副作用，表达式语言本身需有一套完善的安全保障机制。我们不能使用属性绑定表达式做赋值操作，也不能使用增量操作符和修饰符。 
当然，如果我们的表达式调用的属性和方法本身有副作用，Angular2是没办法感知并告知我们。例如我们的表达式调用了getFoo()函数，除非我们已经知道了该函数的作用。不然，如果getFoo()函数修改了一些东西，同时修改的这些东西又被我们绑定到其他地方的话，我们的程序就可能出现问题。Angular2可能会也可能不会显示这些改变后的值，Angular2也可能会检测到这些改变，并抛出警告，但无论怎样这是一种不好的体验。我们的建议是：保证属性绑定的值和调用的方法仅仅是为了返回值，而不是完成其他的操作。
3.2.1.4 返回正确的数据类型
模板表达式应当根据目标属性的类型赋值，如果DOM对象属性需要赋值string类型，则表达式的值必须为string，例如img元素的src属性为图片地址，是一个string类型，则赋值给src的表达式必须返回string类型。number类型、boolean类型和object类型道理一样，如button的disabled属性需要布尔类型，对象类型多半用于组件和指令的赋值，例如，在组件heroDetail里，hero属性需要赋值object类型，则selectHero必须是一个object类型
<hero-detail [hero]="selectedHero"></hero-detail>
3.2.1.5 属性绑定的中括号
中括号是告诉Angular2，后面的值是模板表达式，需要执行计算求值，如果忘了加中括号，Angular2会当做字符串常量赋值给目标属性。
<!-- 错误：currentHero并不会解释成object -->
<hero-detail hero="currentHero"></hero-detail>
但有些情况需要忽略掉中括号，如同时满足下面3个条件：
	1.	目标属性需要赋值string类型
	2.	这个string值是固定的
	3.	初始化的值不需要再变更
	•	在标准的HTML代码里，我们通常是以这个方式初始化HTML属性的值，这个方法同样适用于指令和组件属性的初始化。下面这个例子用了一个固定的string值初始化组件HeroDetailComponent的prefix属性，而不是模板表达式。
<hero-detail prefix="You are my" [hero]="currentHero"></hero-detail>
3.2.1.6 属性绑定还是插值
我们时常会在插值和属性绑定之间做选择。例如下面两个绑定的例子中，插值和属性绑定都起到了同样的效果。
// 插值
<img src="{{heroImageUrl}}">
<div>The title is {{title}}</div>
// 属性绑定
<img [src]="heroImageUrl">
<div [textContent]="'The title is '+ title"></div>
在很多情况下，插值相比属性绑定更为方便。实际上，Angular2在处理插值时会首先把插值转换成相对应的属性绑定。从技术角度而言，二者无所谓孰优孰劣。单单从可读性而言，我们倾向于插值的方法。在实际使用用只需要建立起共同的使用规范，保证代码的统一性就可以了。
3.2.2 HTML元素属性绑定
通常情况下，设置DOM对象的属性值，Angular2推荐使用DOM对象属性绑定，但为啥还会有HTML元素属性绑定呢？原因是并不是所有的元素都有对应的DOM对象属性，如ARIA、SVG以及table中的span属性，他们是纯粹的HTML元素属性，并没有对应的DOM对象属性。 
例如，当我们尝试给colspan动态赋值时候：
<tr><td colspan="{{1+1}}">Three-Four</td></tr> ....
上面代码会抛出一个错误：
Template parse errors:
Can't bind to 'colspan' since it isn't a known native property
正如错误消息说的，td元素的colspan没有对应的DOM对象属性，而插值和DOM对象属性绑定只支持DOM对象属性。所以我们需要HTML元素属性绑定去处理这一类情景的数据绑定。 
HTML元素属性绑定的语法类似于DOM对象属性绑定，不同之处在于我们会在属性名称之前加上attr前缀，属性名和attr用.点符号连接，如下例colspan所示：
<table border=1>
<!-- 表达式计算出colspan=2 -->
<tr><td [attr.colspan]="1 + 1">One-Two</td></tr>
 
<!-- 错误: There is no `colspan` property to set!
<tr><td colspan="{{1 + 1}}">Three-Four</td></tr>
-->
 
<tr><td>Five</td><td>Six</td></tr>
</table>
另一个常用的应用例子是ARIA属性，如：
<!-- 为无障碍浏览设置aria属性 -->
<button [attr.aria-label]="actionName">{{actionName}} with Aria</button>
3.2.3 class属性绑定
我们可以通过class属性绑定，为元素添加和移除样式类。class绑定的语法类似于HTML元素属性绑定，替换前缀attr为class即可,即：[class.class-name]。 
在下面的例子中，我们来看下如何通过class绑定添加和移除”special”类。 
首先我们不通过绑定直接设置类属性：
<!-- 标准HTML样式类设置 -->
<div class="bad curly special">Bad curly special</div>
接下来我们把class绑定到一个字符串上，在本例中，所有的样式类被全部替换：
<!-- 重设元素里所有的样式类 -->
<div class="bad curly special"
[class]="badCurly">Bad curly</div>
最后我们来看下如果需要绑定特殊的类名。如下例所示，当模板表达式求值为true时，Angular会添加相应样式类，当模板表达式求值为false时，会移除掉样式类。
<!-- toggle the "special" class on/off with a property -->
<div [class.special]="isSpecial">The class binding is special</div>
 
<!-- binding to `class.special` trumps the class attribute -->
<div class="special"
[class.special]="!isSpecial">This one is not so special</div>
Todo reference to NgClass directive
3.2.4 style属性绑定
我们可以通过样式绑定设置内联样式。样式绑定类似于HTML元素属性绑定，替换前缀attr为class即可，即：[style.style-property]。
<button [style.color] = "isSpecial ? 'red' : 'green'">Red</button>
<button [style.backgroundColor]="canSave ?'cyan' : 'grey'" >Save</button>
有些样式值是有单位的，如下我们可以设置fontSize属性的值的单位为“em“或”%“。
<button [style.fontSize.em]="isSpecial ? 3 : 1" >Big</button>
<button [style.fontSize.%]="!isSpecial ? 150 : 50" >Small</button>
Todo reference to NgStyle directive
3.3 事件绑定
在第二小节里，我们介绍的绑定方法的数据流向都是由组件数据源流向模板的。但是用户的行为不仅仅是盯着屏幕，有时用户会在输入框中输入文字，有时会点击按钮。诸如此类的用户行为，会使得数据向相反的方向流动，即由模板传递给组件。了解用户行为的唯一方法就是监听某些事件，比如按键，鼠标移动，点击和触摸等，这就需要在模板上绑定事件去追踪这些用户行为。
Angular2的事件绑定语法是由一个等号连接事件目标和模板声明（见第二节）。下面的事件绑定例子是监听button的click事件，click事件触发后会调用组件的onSave()函数。
<button (click)="onSave()">Save</button>
3.3.1 事件目标
小括号之间的名字标识目标事件，在下面的例子中，目标就是按钮的click事件。
<button (click)="onSave()">Save</button>
也可以用on-前缀替代小括号：
<button on-click="onSave()">On Save</button>
元素的事件是最常见的绑定目标，不过Angular2会优先匹配指令的事件，如下所示：
<!-- `myClick`是`MyClickDirective`的事件属性 -->
<div (myClick)="clickMessage=$event">click with myClick</div>
如果事件名称既不匹配HTML元素的事件，也不是某个已知指令的事件属性，Angular2就会抛出一个”未知指令“的错误。
3.3.2 $event对象和事件处理表达式
在事件绑定中，当事件被触发，Angular2会执行对应的模板声明，模板声明负责处理事件逻辑，例如从HTML控件里读取一个值并记录到数据model里。模板声明在事件绑定中会获得事件的一些信息（如用户输入数据），这个信息的传递通过一个事件对象名为$event。$event对象的类型取决于目标事件，如果目标事件是一个DOM元素事件，那么$event就是一个DOM事件对象（有target以及可以读取到target.value） 
请看下面的例子：
<input [value]="currentHero.firstName"
(input)="currentHero.firstName=$event.target.value" >
firstName变量的值绑定到input的value属性，并监听input元素的输入事件。当用户输入的内容发生改变，输入事件被触发，对应的模板声明会被执行，且该模板声明的上下文里包含了一个DOM事件对象变量（$event），通过$event.target.value来读取用户的输入值并更新数据源的firstName变量。
3.3.3 自定义事件
通过Angular2提供的EventEmitter对象，指令可以发起自定义事件。指令创建一个EventEmitter并作为属性对外暴露。指令调用EventEmitter.emit(payload)来触发一个事件，其中payload可以传入任何值，父指令监听事件并通过$event对象获取payload。 
上面的描述比较抽象，下面结合todoApp例子讲解，我们编写了一个ItemDetailComponent，模板片段如下
template: `
<div>
<p>{{item.text}}</p>
<span>{{item.createTime}}</span>
<button (click)="delete()"除</button>
</div>
`
该组件有一个删除按钮，点击按钮时会触发组件的delete方法。我们希望具体的删除逻辑放到父组件里处理，但事件是在子组件里触发，所以我们需要把子组件的事件向父组件传递，借助EventEmitter可以实现该功能。
deleteRequest = new EventEmitter<TodoItem>();
 
delete() {
this.deleteRequest.emit(this.item);
}
可以见到，我们新建了一个EventEmitter实例去传递删除事件，并把当前的item值作为payload传入。当使用这个组件时候，deleteRequest作为事件属性来项父组件传递事件，并且item对象会被赋值到$event对象里。
<item-detail (deleteRequest)="deleteTodoItem($event)" [item]="currentTodoItem"></item-detail>
如此一来，当点击ItemDetailComponent的删除按钮时，父组件的deleteTodoItem函数即会被触发。
3.4 双向绑定
在开发数据输入的表单时，我们既要显示组件数据到表单上，同时当表单上的数据变更时，也需要同步到组件数据里。这时候我们需要数据能双向流通，前面的小节里我们已经学过了双向的数据流动绑定方式：
<input [value]="currentHero.firstName"
(input)="currentHero.firstName=$event.target.value" >
开发中我们经常碰到双向绑定情景，显然这看起来不够简洁。Angular2里创建了NgModel指令帮助我们更便捷的进行双向绑定。
<input
[ngModel]="currentHero.firstName"
(ngModelChange)="currentHero.firstName=$event">
这样看起来好一点，但还是不够，我们没必要对同一个数据源进行两次数据绑定，于是Angular2指定了一种新语法来支持数据绑定[()]:
<input [(ngModel)]="currentHero.firstName">
[]是实现数据流从组件数据源到模板，而()是实现从模板到数据源，把这两者合起来[()]正是双向绑定的语法，形象的说像是一个盒子里放着一个香蕉。你也可以用下面的方法实现双向绑定，二者效果是一样。
<input bindon-ngModel="currentHero.firstName">
3.5 内置指令
早期版本的Angular提供了70多个内置指令，社区则贡献了更多地指令。同时，在内部应用程序中，个人开发人员更是创建了数不清的私有指令。 
在Angular2中，我们不再需要如此之多的指令。我们更多地使用功能和表现更加强大的Angular2绑定系统达到同样的效果。如下例所示，如果我们可以简单的通过绑定去处理一个click事件，为什么还要去创建一个指令呢？
<button (click)="onSave()">Save</button>
指令仍然在简化复杂任务方面发挥着巨大的作用，Angular仍然提供了一些内置指令，我们也会去实现自定义指令，只是没有那么多了而已。 
接下来，我们会了解一些经常被适用到的内建指令。
3.5.1 NgClass
我们经常通过添加和移除CSS类去动态的控制元素的显示样式。我们可以通过绑定NgClass同时添加或移除多个CSS类。 
对于单个样式类的添加和移除，我们更倾向于使用类绑定。
<!-- toggle the "special" class on/off with a property -->
<div [class.special]="isSpecial">The class binding is special</div>
但当需要同时添加或移除多个CSS类时，使用NgClass是一个更好的选择。我们使用NgClass的方法就是给它绑定一个key:value对象，其中key对应于一个类名，类名是否插入到HTML里取决于对应的值是否为true。假设有这样一个名为setClasses的组件方法，如下所示：
setClasses() {
let classes = {
saveable: this.canSave, // true
modified: !this.isUnchanged, // false
special: this.isSpecial, // true
}
return classes;
}
接下来添加一个NgClass属性绑定去调用该方法：
<div [ngClass]="setClasses()">This div is saveable and special</div>
3.5.2 NgStyle
我们可能需要基于组件的状态去设置内联样式。通过绑定NgStyle可以同时设置多个内联样式。对于单个样式值的设置，我们更倾向于使用样式绑定。
<div [style.fontSize]="isSpecial?'x-large':'smaller'">This div is x-large</div>
但当需要同时设置多个内联样式时，使用NgStyle是一个更好的选择。我们使用NgStyle的方法就是给它绑定一个key:value对象，其中key对应于一个样式名，vaule对应于该样式的具体值。假设有这样一个名为setStyles的组件方法，如下所示：
setStyles(){
return {
//CSS property names
'font-style':this.canSave ? 'italic':'normal', //italic
'font-weight':!this.isUnchanged ? 'bold':'normal', //normal
'font-size':this.isSpecial ? 'x-large':'smaller' //x-large
}
}
接下来添加一个NgStyle属性绑定去调用该方法：
<div [ngStyle]="setStyles()">This div is italic, normal weight, and x-large</div>
另外，我们再返回对象中，也可以以驼峰的形式书写属性名，结果是一样的：
setStyles(){
return {
//CSS property names
fontStyle:this.canSave ? 'italic':'normal', //italic
fontWeight:!this.isUnchanged ? 'bold':'normal', //normal
fontSize:this.isSpecial ? 'x-large':'smaller' //x-large
}
}
3.5.3 NgIf
通过绑定NgIf指令到一个求值为真的表达式，我们可以再DOM中添加一个元素的子树（包含元素和它的子元素）。
<div \*ngIf="currentHero">Hello, {{currentHero.firstName}}</div>
相反，如果表达式求值为false时，元素的子树将会在DOM中被移除。 
前面我们了解设置[class.hidden]或者[style.display]可以操作元素显示隐藏。 
我们可以通过类绑定或者样式绑定显示或隐藏一个元素的子树：
<!-- isSpecial is true -->
<div [class.hidden]="!isSpecial">Show with class</div>
<div [class.hidden]="isSpecial">Hide with class</div>
 
<!--heroDetail is in the DOM but hidden -->
<hero-detail [class.hidden]="isSpecial"></hero-detail>
 
<div [style.display]="isSpecial?'block':'none'">Show with style</div>
<div [style.display]="isSpecial?'none':'block'">Hide with style</div>
实际上隐藏子树和NgIf的移除子树是完全不同的。当子树被隐藏起来时，它仍然在DOM中存在。存在于子树中的组件及其状态会被保存起来。Angular2会继续检查属性的改变，虽然这些属性已不可见。隐藏起来的子树仍然会占用大量的内存和计算资源。当NgIf为false时，Angular会把元素的子树从DOM中物理移除，子树中的组件及其状态会被销毁，且会释放出占用的内存资源，使得用户获得更好的性能。所以显示/隐藏技术更适用于较小的元素树。当元素树较大是我们要谨慎使用，NgIf或许是一个更好的选择。
3.5.4 NgSwitch
当我们希望从一系列可能的元素树中，选择出符合条件的元素树，并将它添加到DOM中时，就可以考虑绑定NgSwitch指令。举个例子：
<span [ngSwitch]="toeChoice">
<span *ngSwitchWhen="'Eenie'">Eenie</span>
<span *ngSwitchWhen="'Meanie'">Meanie</span>
<span *ngSwitchWhen="'Miney'">Miney</span>
<span *ngSwitchWhen="'Moe'">Moe</span>
<span *ngSwitchDefault>other</span>
</span>
首先，绑定NgSwitch指令到父元素，指令的模板表达式返回一个值A，该值可以是任何类型。然后子元素通过*ngSwitchWhen指定一个特定值B。当A和B的值相等时，则显示该子元素，否则隐藏。若所有的子元素指定的值都不匹配时，就显示指定*ngSwitchDefault的子元素。
3.5.5 NgFor
NgFor是一个循环指令，也是一种定制输出方法。我们的目的是展示一个列表项，我们还定义了一套共用的HTML模板，Angular2需要使用这套模板去展示列表的每一项。下面是一个将NgFor应用于一个简单的<div>的例子：
<div *ngFor="#hero of heroes">{{hero.fullName}}</div>
我们还可以在组件元素中应用NgFor：
<hero-detail *ngFor="#hero of heroes" [hero]="hero"></hero-detail>
// todo more description
在上面的两个例子中，*ngFor指令遍历了heroes数组，数组中的每个实例都应用到了元素上，Angular2为数组中每个hero对象创建了一个新的模板实例。 
hero前面的#号标识了名为hero的局部模板变量。我们在模板中引用这个变量，第一个例子中我们通过插值读取变量的属性，我们还可以像第二个例子那样，通过绑定的组件属性传递改变量，关于局部模板变量下一章节详解。
NgFor中的index
NgFor指令还支持一个可选的索引，在每次循环过程中，索引值从1增长到数据的长度。在模板中，我们可以通过另外一个局部模板变量i获取到它的值。如下例所示：
<div *ngFor="#hero of heroes, #i=index">{{i+1}} - {{hero.fullName}}</div>
3.6 局部模板变量
在之前的很多例子中，我们已经使用过模板局部变量。angular2提供了一种简单的语法来将元素映射为局部变量，即以“#”或者“var-”开头的，后续部分以合法的变量加合组成，这就满足了在模板中不同元素间可能的相互调用，如我们之前使用过的例子：
<template ngFor #hero [ngForOf]="heroes"><hero-detail [hero]="hero"></hero-detail></template>
"hero"前面的#号前缀标识我们正在定义一个hero变量，其中我们在外层的template元素上定义的hero变量，在Angular遍历heroes列表的时候，它会被赋予当前的hero对象，在里层的hero-detail组件元素上，hero变量再次出现，这也解释了在模板中不同元素间可能的相互调用。
局部模板变量的作用域
首先我们要明确模板变量的作用域范围，即我们可以在相同的元素、在兄弟元素或者在其任意子元素中引用到局部模板变量，我们获取局部模板变量就取决于其上下文。如上例中，我们在template中定义了hero变量，这意味着我们能够在当前的元素或者其子元素“hero-detail”上应用该变量。
NgForm和模板局部变量
在下面的章节中，我们将会介绍表单的相关内容，其中包含NgForm内置指令，但是这里不妨碍我们进一步加深对模板局部变量的理解。我们直接上个简单的例子：
<form（ngSubmit)="onSubmit(theForm)" #theForm="ngForm">
 <div class="form-group">
 <label for="name">Name</label>
 <input class="form-control" required ngControl="firstName" [(ngModel)]="currentHero.firstName">
 <button type="submit" [disabled]="!theForm.form.valid">Submit</button>
 </div>
</form>
这个例子中，我们通过使用“#”符号和“theForm”建立了一个引用控件组对象（不是form元素）的局部变量，这个变量的最大作用是，它的value属性是一个简单的JSON对象，键对应input元素的ng-control属性，值对应于input元素的值。Angular内置NgForm指令的引用，是对原生HTML表单元素的包装，并且赋予了类似跟踪用户输入有效性等的额外功能，比如我们可以通过检查theForm.form.valid去修改提交按钮的禁用状态，以及将含有丰富信息的对象传递给父组件的onSubmit方法。
3.7 输入和输出属性
本节我们将讨论输入输出属性的概念，我们需要给出一个例子来说明：
<hero-detail [hero]="currentHero" (deleted)="onHeroDeleted($event)"></hero-detail>
HeroDetail.hero和HeroDetail.deleted都位于绑定表达式的左边。其中，HeroDetail.hero是属性绑定的目标，HeroDetail.deleted是事件绑定的目标。数据通过模板表达式流向HeroDetail.hero目标属性，因此HeroDetail.hero对于HeroDetail而言是一个输入属性。 在模板表达式中，事件流出HeroDetail.deleted目标属性，传递给接收者，因此对于HeroDetail而言，HeroDetail.deleted是一个输出属性。 上面绑定的组件成员，它们位于绑定声明右边的模板表达式中，该成员是被绑定的数据源，而不是绑定目标。如“currentHero”和“onHeroDeleted”，它们既不是HeroDetail的输入，也不是输出，它们仅仅是绑定中的数据源。
那到目前为止，我们就很清楚这些概念了，在属性绑定或者事件绑定等号右边的模板表达式或者声明，仅仅是绑定中的数据源，这些数据源关联到等号左边的指令属性绑定目标中，这些属性指令就是输入或者输出属性。
输入和输出属性的别名
通常我们的输入输出属性名要有别于内部命名，这种情形在属性指令经常使用到，例如，当我们在一个div标签中使用一个事件绑定的指令“myClick”：
<div (myClick)="clickMessage=$event">click with myClick</div>
然而，指令名称通常是选择的范围是少之又少的，这些指令名称可能还不太描述的清这些属性的用途，幸运的是，当我们使用不同的内部命名的时候，我们能有一些公共的名称符合我们的传统预期。上面的例子中，我们为指令的click属性设置了一个“myClick”的别名。我们能通过输入输出的修饰器来指定别名,即: @Output(alias) propertyName = ...，如：
@Output('myClick') clicks = new EventEmitter<string>();
我们也能在组件中通过“inputs”和“outputs”数组来定义属性别名，如下：
@Directive({outputs: ['clicks: myClick']})
3.8 表单
表单在我们的web应用中是至关重要的，表面上看，表单最直截了当的就是用户输入数据，点击提交这么简单。但事实上，表单所呈现的形式是非常复杂多变的，比如我们angular表单可以实现用户控制，监视变化，验证输入、错误信息处理和数据绑定等功能。
本节将详细介绍angular2表单，主要是从技巧方面来认识表单在angular2中带给用户的良好体验，具体如下：
	•	通过组件和模板来创建一个表单；
	•	通过ngModel双向数据绑定的例子来了解如何在input中读写值；
	•	angular2相关表单指令的运用，如NgForm、NgForm、NgForm、NgForm和NgCongrolGroup等；
	•	表单局部变量的运用；
	•	表单错误信息和处理或者Validators验证处理等。
	•	1.表单组件类和表单模板
angular2表单是基于HTML的模板及其控制该模板数据以及用户交互的组件组成，我们需要引入一个Componet，这意味着可以在该组件中定义选择器和模板或者引入一个外链的html模板。接下来定义一个组件类，其作用是控制表单相关属性的表现，定义表单方法等。
如下面的例子：【暂时用官网的例子。TODO...】
import {Compontent} from ‘angular2/core’; import {NgForm} from ‘angular2/common’; import {Hero} from ‘./hero’; @Component ({ selector: ‘hero-form’, templateUrl: ‘app/hero-form.compontent.html }) export class HeroFormCompent { powers = [‘ReallySmart’,’Super Flexible’,’Super Hot’,’Weather Changer’]; model=new Hero(18,’DrIQ’,this.powers[0],’Chuck Overstreet’); submitted = false; onSubmitt(){this.submitted= true;}
在这个例子中，在引入的Component中，需要定义一个selector选择器，这表示我们能够在父模板中插入该表单。同样的，模板可以是外链URL模板也可以直接包裹在template键对应的值中。如：
template: `<form #f="ngForm" (submit)="search(f.value)"> <select> <option value="web">网页</option> <option value="news">新闻</option> <option value="image">图片</option> </select> <input type="text" ngControl="kw"> <button type="submit">搜索</button> </form>`
而控制表单的属性或者用户行为等，我们将定义一个类来处理，如HeroFormCompent类，我们定义了相关的属性，提交数据方法等。
2.表单指令
2.1 NgForm
NgForm指令为表单建立一个控件组对象，它包含当前选择器所在的form标签，关于NgForm请看下面的例子：
import {Component} from "angular2/core"; import {bootstrap} from "angular2/platform/browser"; import {CORE_DIRECTIVES,FORM_DIRECTIVES} from "angular2/common"; //组件 @Component({ selector:"xx-app", directives:[FORM_DIRECTIVES,CORE_DIRECTIVES], template:` <form #f="ngForm" <input type="text" ngControl="title"> (ngSubmit)="onSubmit(f.value)" </form> ` })
2.1.1 指令依赖声明
NgForm指令包含在预定义的数组变量FORMDIRECTIVES中，所以我们要在组件注解的directives属性中优先声明FORMDIRECTIVES，这样就可以直接使用NgForm指令了。
2.1.2 局部变量
通过使用“#”符号，我们可以创建一个引用控件组对象的局部变量，如上例中的变量f，这个变量它的value属性是一个JSON对象，该对象的键对应的是表单中input元素的ng-control属性，值对应的是input元素的值。接下来我们介绍NgControl。
2.2.NgControl
2.2.1 NgControl的运用
我们可以在input标签中添加ngControl属性，NgControl将创建一个新的Control并动态的将它添加到父ControlGroup中，同时绑定一个DOM元素到这个新的Control，这就将这个input标签和Control联系起来了，我们访问该标签将直接通过这个ngControl的属性值来访问。
需要注意的是，ngControl必须是作为一个NgForm或者NgFormModel的后代来使用，否则将会报错，因为这个指令需要将创建的控件对象添加到祖先（NgForm或者NgFormModel）所创建的控件中。
在这里，值得一提的是NgControlNmae，它的选择符是[ngControl]，这就意味着，你必须和ngControl来搭配使用，这个指令才会发挥它的作用。NgControlName指令为宿主DOM对象创建一个控件对象，并将这个对象以ngControl属性指定的名称绑定到DOM对象上，举个例子，如我们最常用的用户名和密码表单：
<form #f="ngForm"> <input class="user-name" type="text" ngControl="user"> <input class="password" type="password" ngControl="password"> </form>
我们创建了两个Control对象，NgControlName指令为宿主DOM对象创建两个控件对象，然后将ngControl属性指定的名称user、password绑定到了其对应的input标签对应的DOM数上。这样的好处是我们可以很方便的通过控件组获取对应的值，也能实现ngModel模型与表单的双向绑定，下一节我们将介绍NgModel。
2.2.2 ngControl监视状态
表单不仅仅是数据的绑定，同样的，我们也希望能够监测到表单的状态，NgControl指令能够保持对状态的监视，除此之外，它会在这下面的三个状态值中影响着当前表单的控制器。
	•	状态

	•	True

	•	False

	•	control是否被访问

	•	ng-touched

	•	ng-untouched

	•	control是否发生了变化

	•	ng-dirty

	•	ng-pristine

	•	control是否合法有效

	•	ng-valid

	•	ng-invalid

	•
通过监测NgControl状态的改变，我们能设置我们想要的特殊css类来更新控制器，比如能够通过监视状态合法性的属性ng-valid和ng-invalid来改变控制器是否需要弹出或者显示输入非法的状态提醒，如显示、隐藏错误信息等。我们能瞬间探测到这些状态的改变，同时我们可以马上为我们的表单组件添加对应的处理。以下是对这些状态使用的一些例子：
// todo ... 
2.3 NgModel
2.3.1 NgModel的运用
在表单中，我们常常需要用到这样的场景，在model数据结构有变化的时候，我们希望能够及时的反应在表单中，同样的，我们在操作表单的时候，也是需要表单的变化需要实时的在model中有响应的。也就是说，我们需要同一时间去显示、监听和摘录数据。
angular2采用的是ngModel来实现数据的双向绑定的，NgModel指令可以令表单和模型（model）的数据绑定超级简单，它的语法是：[(ngModel)]=“...”，例子如下。
<input type=”text” class=”form-controt” required [(ngModel)]=”model.name”> TODO:监视这个表单的值：{{model.name}}
2.3.2 NgModel双向绑定原理
在模板语法里，我们已经了解过了属性绑定和事件绑定，在属性绑定里，值产生于模型赋值给目标属性，通过中括号-[]来包裹这个属性，那么我们的模型也将通过这个中括号内的属性值来辨识这个目标属性。这是一种由模型向视图的单项数据绑定。而事件绑定则相反，在事件绑定中，目标属性对应表单的变化的值将赋予给模型，通过小括号-()来包裹这个属性，这个包裹的属性将会标识模型中对应该目标属性名的变化。这是一种反向的视图向模型的单向数据绑定。这就是[()]实现数据双向绑定的方式，很好的预示将要发生什么。
如上面的例子，我们可以改写成这样：
<input type=”text” class=”form-control” required [ngModel]=”model.name” (ngModelChange)=”model.name=$event”> TODO:监视这个表单的值： {{model.name}}
该表单中，模板表达式：model.name=$event是被用来发现来自于DOM事件的$event事件，ngModelChange不是一个input元素事件，本身不会产生一个DOM事件，实际上它是NgModel指令的一个事件属性，它是能够返回输入框的一种angular的EventEmitter属性，这种属性能够精确的捕获我们分配给模型“anyName”属性的值。在angular2表单中，我们看到[(anyName)]时，它预示着这个anyName指令将拥有一个该属性的输入值和一个对应着anyName-change的输出值。
2.4 NgSumit
用户填完表单之后，我们需要获取表单的完整数据以便提交。通常我们会在表单的底部添加一个提交按钮并设置其type的值等于submit，按钮本身不做任何事情但是却能监听表单的提交这个动作，但是此刻的提交没什么作用，为此，angular2提供了一个NgSubmit指令于form标签，这样我们就可以绑定事件到模型的submit方法上用来出来表单的提交了。例子如下：
import { Component } from 'angular2/core'; import { FORM_DIRECTIVES } from 'angular2/common'; @Component({ selector: 'demo-form', directives: [FORM_DIRECTIVES], template: ` <form #f="ngForm" (ngSubmit)="onSubmit(f.value)"> <input type="text" ngControl="sku"> <button type="submit" class="button">Submit</button> </form> ` }) export class DemoForm { onSubmit(value: string): void { console.log('you submitted value: ', value); } }
该例子中，我们定义了一个模板局部变量#f，并用NgForm指令来初始化它的值，这样我们就能通过submit来获取该表单需要提交的数据结构了。
3.9 模板语法操作符
3.9.1 pipe
1.管道
我们的很多应用场景是基于这样一个简单的任务，获取数据，转换过滤后再展示给用户，angular2中我们引入了管道(Pipes)的概念，即管道是用来将数据模型中的数据经过过滤转换，然后通过模板内并展示给用户，这样做是为了更好的用户体验，例如从视图模型中直接获得的数据，不一定完全是我们想要的格式或者适合于人们查看的，举个例子，我们需要获取一个班级所有学生的平均分：
<div>this class‘s average is： {{getAvgScore()}}</div>
虽然通过视图模型中的getAvgScore方法获取到了我们需要的平均分来展示了，但是可能我们获取到的数据是一个除不断的多位小数位的数据，那么这样的结果看上去是不那么顺眼的。除了在视图模型的方法来控制小数位外，我们也可以利用管道来格式化这样的数据，也就是在模板里改变数据的显示格式。这就是angular2中管道的作用。
1.1 管道的用法
在angular2中，管道是在模板中对输入数据进行变换，并输出变换后的结果。在模板的内嵌表达式中，使用管道操作符“|”和其右边的管道方法来实现一个管道操作，使用“:”来向管道传入参数，所有的管道都是沿用这样这的一种机制。我们举个简单的例子来说明一下管道的使用：
import {Component} from 'angular2/core' @Component({ selector: 'hero-birthday', template: `<p>The hero's birthday is {{ birthday | date:"MM/dd/yy" }}</p>` }) export class HeroBirthday { birthday = new Date(1988,3,15); // April 15, 1988 }
我们通过视图组件获取到我们要输出的生日日期birthday，通过插值和模板联系起来，在模板的内嵌表达式中，我们输出生日组件的值是通过管道操作符“|”和其右边的内置管道Data Pipe方法来实现的。至于管道的参数，我们在内置管道Data Pipe方法后边加冒号(:)来添加参数值，并且如果有多个参数的话，我们用多个冒号来区分开参数就好了。
最后要说一下的是，angular2管道可以链式运用。我们可以将多个管道通过“|”链式的书写到一个实用的组合体上，如我们将birthday链到DatePipe和UpperCasePipe上以便我们将生日日期显示为大写，下面的日期将会是APR 15, 1988：
<p>The chained hero's birthday is {{ birthday | date | uppercase}}</p>
1.2 管道的内置方法
为了方便使用，Angular2针对之前的经验，设置了一套常用的内置管道，如DatePipe，JsonPipe，UpperCasePipe， LowerCasePipe，CurrencyPipe，PercentPipe及SlicePipe.其目的是在任何模板中都可以便捷使用。我们将详细介绍他们的具体用法。
DatePipe是对日期\时间数据进行格式变换，在模板中直接使用date来引用DatePipe，参数用来指定所需的格式，需要说明的是，不需要再在视图组件中声明，
 <p>{{day | date: 'yyMMdd'}}</p>
JsonPipe是将Json数据对象转换成字符串格式输出，在模板中使用json来引用JsonPipe，其实现是基于JSON.stringify()，这个管道主要用来调试。
<p>{{key1: "value1", key2: "value2"}} | json</p>
UpperCasePipe&LowerCasePipe用于将输入的字符串转换成大小写，在模板中直接使用uppercase&lowercase即可。
<p>{{“this is a demo” | uppercase}} | json</p>
CurrencyPipe是将获取到的金钱数转换成特定格式的数字，在模板中直接使用currency来引用CurrencyPipe。
<p>{{price | currency: 'USD': true}}</p>
PercentPipe是将数值转换成百分比，在模板中使用percent来引用PercentPipe即可。
<p>{{1.23456 | percent: '1.2-3'}} | json</p>
例子中的“:'1.2-3'”表示调用这个这个管道时传入的参数为“'1.2-3'”，对于PercentPipe，这三个数字分别依次表示最少整数位、最少小数位和最多小数位。
SlicePipe是用来提取输入字符串中的指定切片，在模板中使用slice来引用SlicePipe。第一个参数指定切片的起始索引，第二个参数指定切片的终止索引的下一个。
<p>{{ '01234567890' | slice:1:4 }}</p>
2.自定义管道
通过上一节的内置管道可以看出，angular2内置的管道并不是特别的丰富，更进一步的是angular2允许自定义管道。自定义一个管道需要以下两个步骤：
2.1、声明元数据
和实现一个组件类似，一个自定义的管道也是具有特定元数据的类，如
import {Component,Pipe} from "angular2/core"; @Pipe({name: "anyPipeName"}) class anyPipeNamePipe {...}
Pipe注解为被装饰的类附加了管道元数据，其最重要的属性是name，也就是我们在模板中调用这个管道时使用的名称。上面定义的管道，我们可以在模板中这样使用：
<p>{{ data | anyPipeName }}</p>
2.2 实现transform方法
定义一个自定义的管道必须实现一个预定的方法transform(input,args)，其中这个方法的input参数代表输入数据，args参数代表输入参数，返回值将被作为管道的输出。
import {Component,Pipe} from "angular2/core"; @Pipe({name: "anyPipeName"}) class anyPipeNamePipe { transform(input,args){ return ...; } }
通过以上定义一个自定义的管道，需要说明的是这样的一个pipe需要以下这样几个关键的点：
	•	管道是一个带有pipe元数据的类；
	•	这个类实现一个转换方法，通过一个输入值和一个可选的数组字符参数，最终返回转换后的值；
	•	数组参数中的某一项将每一个参数传递给pipe；
	•	我们通知Angular这是一个引入过Angular核心库的@Pipe服务
	•	这个@Pipe服务带有一个参数，该参数它的值是一个pipe名，我们将使用在一个模板表达式中，它可以是一个合法的Javascript定义。
	•	最后我们通过例子来说明自定义管道的使用，但是需要特别注意的是：
	•	在组件的模板中使用自定义管道之前，需要预先声明一下，即使用Component注解的pipes属性进行声明：pipes:[EzPipe]，以便Angular2注入。
	•	如果我们忽视去列出我们的自定义pipe，Angular2将会报错。我们不需要在先前的例子中列出内置指令是因为所有Angular2内置的pipes是预先注册过的，自定义的pipes必须手动注册。
	•	自定义管道完整的例子如下：
import {Component,Pipe} from "angular2/core"; import {bootstrap} from "angular2/platform/browser"; @Pipe({name:"title"}) class TitlePipe{ transform(input,args){ return input.split(" ") .map(word => word[0].toUpperCase() + word.slice(1)) .join(" "); } } @Component({ selector:"Demo-app", template:` <p>{{text | title}}</p> `, pipes : [TitlePipe] }) class DemoApp{ constructor(){ this.text = "what a wonderful world!"; } } bootstrap(DemoApp);
3.管道状态
3.1 无状态的管道
无状态的管道是一个纯粹的方法，流入的数据将不会记录任何东西，或者不会导致任何的副作用。大多数的管道是无状态的，例如我们之前例子的Datapipe就是一个无状态的pipe。据我们之前了解到的管道，包括angular2内置的管道，都具有这么一个特点，就是其输出仅仅是依赖于输入，这就是angular2中的无状态管道，对于无状态的管道，当视图组件的输入没有变化时，angular2框架是不会重新计算管道的输出的。
3.2 有状态的管道
有状态的管道在概念上类似于面向对象编程类，它们可以管理数据的变换，例如管道创建一个HTTP请求，存储它的返回和显示结果，就是一个有状态的pipe。需要注意的是，检索或请求数据的管道应该要谨慎使用，因为使用网路数据往往会引入错误的条件，在javascript中处理更优于在模板中处理。我们可以为了特定的后端和基本的异常捕获而创建自定义的pipe来减轻任何风险。
angular2对有状态的管道定义的关键在于使用使用Pipe注解的属性“pure”，并设置该属性的值为false即可，其作用是要求angular2框架在每个变化检查周期都执行管道的transform()方法。下面我们给一个例子，实现一个10到0的倒数计时器。
import {Component,Pipe} from "angular2/core"; import {bootstrap} from "angular2/platform/browser"; @Pipe({ name : "countdown", pure : false }) class CountdownPipe { transform(input){ this.initOnce(input); return this.counter; } initOnce(input){ this.counter = input; this.timer = setInterval(() => { this.counter--; if(this.counter === 0) clearInterval(this.timer); }, 1000); } } @Component({ selector:"demo-app", template:`<h1>this is a stateful pipe : {{ 10 | countdown }}</h1>`, pipes : [CountdownPipe] }) class DemoApp{} bootstrap(DemoApp);
从这个例子中可以看出，自定义管道countdownPipe的输出不仅依赖输出，还依赖与其内部的变化或者运行状态。
而angular2中，AsyncPipe是有状态管道的一个标志性的例子，AsyncPipe它的输入是一个异步对象：Promise对象、Observable对象或者EventEmitter对象，并且自动的订阅(subscrib)输入对象，最终每当异步对象产生新的值，AsyncPipe会返回这个新的值，它的有状态性是因为pipe维护一个输入的订阅并且它的返回值也依赖于这个订阅器。下面给出的例子，我们将用AsyncPipe绑定一个简单的promise给一个view。
import {Component} from 'angular2/core'; // Initial view: "Message: " // After 500ms: Message: You are my Hero!" @Component({ selector: 'hero-message', template: 'Message: {{delayedMessage | async}}', }) export class HeroAsyncMessageComponent { delayedMessage: Promise<string> = new Promise((resolve, reject) => { setTimeout(() => resolve('You are my Hero!'), 500); }); }
3.3 管道无状态和有状态的区别
管道的有状态和无状态的区别，关键在于是否是需要Angular2框架在输入不变的情况下依然持续地进行变化检测，而angular2的无状态的管道是依赖输入的，即同样的输入，总是产生同样的输出。举个例子，例如我们上面的管道，当我们输入一个默认的数字后，输出值依赖其内部的运行状态变化，而无状态的管道，例如一个加减乘除的管道，在Angular2中，它被视为无状态的，因为它的一次输入不会产生多次输出。
3.9.2 Elvis操作符(?.)
在angular中，我们在模板中可能会引入视图模型中的数据，这些数据可能是某个对象的属性，或者是多个对象的引用，当引用中出现null和undefined的属性的时候，可能会引起相关的问题。
<p>The current hero's name is {{currentHero.firstName}}</p>
上面的例子中，当“firstName属性”为空时，视图仍然能显示，但模板最终只显示“The current hero's name is ”，甚至当“currentHero”为null或者undefined时，JavaScript将会抛出TypeError异常，这样导致最终的整个视图不见了，看不到最终的效果展示。然而，我们能想到的最初解决方案就是在模板视图中加判断条件，如我们可以使用NgIf去解决这个问题。
<!-- No hero, div not displayed, no error --> <div *ngIf="nullHero">The null hero's name is {{nullHero.firstName}} </div> 
// 又或者是 <div>The null hero's name is {{ nullHero && nullHero.firstName }}</div>
angular2的“Elvis”操作符提供了一种方法来解决获取到的属性或者对象为null和undefined的问题，Elvis操作符即“?.”，如下面的例子，是为了方便避免属性路径上的空值，当表达式第一次遇到空值时，就会停止执行，显示为空白，但应用程序继续运行，且不会报错。
<p>The current hero's name is {{currentHero?.firstName}}</p>
尤其在属性路径很长的时候，这个操作符就表现出了它的优越性，如a.b.c.d这样的属性操作去避免控制导致报错的时候，我们可以这么完美的去使用：
a?.b?.c?.d
 
 
管道（Pipes）
1.管道
我们的很多应用场景是基于这样一个简单的任务，获取数据，转换过滤后再展示给用户，angular2中我们引入了管道(Pipes)的概念，即管道是用来将数据模型中的数据经过过滤转换，然后通过模板内并展示给用户，这样做是为了更好的用户体验，例如从视图模型中直接获得的数据，不一定完全是我们想要的格式或者适合于人们查看的，举个例子，我们需要获取一个班级所有学生的平均分：
<div>this class‘s average is： {{getAvgScore()}}</div>
虽然通过视图模型中的getAvgScore方法获取到了我们需要的平均分来展示了，但是可能我们获取到的数据是一个除不断的多位小数位的数据，那么这样的结果看上去是不那么顺眼的。除了在视图模型的方法来控制小数位外，我们也可以利用管道来格式化这样的数据，也就是在模板里改变数据的显示格式。这就是angular2中管道的作用。
1.1 管道的用法
在angular2中，管道是在模板中对输入数据进行变换，并输出变换后的结果。在模板的内嵌表达式中，使用管道操作符“|”和其右边的管道方法来实现一个管道操作，使用“:”来向管道传入参数，所有的管道都是沿用这样这的一种机制。我们举个简单的例子来说明一下管道的使用：
import {Component} from 'angular2/core' @Component({ selector: 'hero-birthday', template: `<p>The hero's birthday is {{ birthday | date:"MM/dd/yy" }}</p>` }) export class HeroBirthday { birthday = new Date(1988,3,15); // April 15, 1988 }
我们通过视图组件获取到我们要输出的生日日期birthday，通过插值和模板联系起来，在模板的内嵌表达式中，我们输出生日组件的值是通过管道操作符“|”和其右边的内置管道Data Pipe方法来实现的。至于管道的参数，我们在内置管道Data Pipe方法后边加冒号(:)来添加参数值，并且如果有多个参数的话，我们用多个冒号来区分开参数就好了。
最后要说一下的是，angular2管道可以链式运用。我们可以将多个管道通过“|”链式的书写到一个实用的组合体上，如我们将birthday链到DatePipe和UpperCasePipe上以便我们将生日日期显示为大写，下面的日期将会是APR 15, 1988：
<p>The chained hero's birthday is {{ birthday | date | uppercase}}</p>
1.2 管道的内置方法
为了方便使用，Angular2针对之前的经验，设置了一套常用的内置管道，如DatePipe，JsonPipe，UpperCasePipe， LowerCasePipe，CurrencyPipe，PercentPipe及SlicePipe.其目的是在任何模板中都可以便捷使用。我们将详细介绍他们的具体用法。
DatePipe是对日期\时间数据进行格式变换，在模板中直接使用date来引用DatePipe，参数用来指定所需的格式，需要说明的是，不需要再在视图组件中声明，
 <p>{{day | date: 'yyMMdd'}}</p>
JsonPipe是将Json数据对象转换成字符串格式输出，在模板中使用json来引用JsonPipe，其实现是基于JSON.stringify()，这个管道主要用来调试。
<p>{{key1: "value1", key2: "value2"}} | json</p>
UpperCasePipe&LowerCasePipe用于将输入的字符串转换成大小写，在模板中直接使用uppercase&lowercase即可。
<p>{{“this is a demo” | uppercase}} | json</p>
CurrencyPipe是将获取到的金钱数转换成特定格式的数字，在模板中直接使用currency来引用CurrencyPipe。
<p>{{price | currency: 'USD': true}}</p>
PercentPipe是将数值转换成百分比，在模板中使用percent来引用PercentPipe即可。
<p>{{1.23456 | percent: '1.2-3'}} | json</p>
例子中的“:'1.2-3'”表示调用这个这个管道时传入的参数为“'1.2-3'”，对于PercentPipe，这三个数字分别依次表示最少整数位、最少小数位和最多小数位。
SlicePipe是用来提取输入字符串中的指定切片，在模板中使用slice来引用SlicePipe。第一个参数指定切片的起始索引，第二个参数指定切片的终止索引的下一个。
<p>{{ '01234567890' | slice:1:4 }}</p>
2.自定义管道
通过上一节的内置管道可以看出，angular2内置的管道并不是特别的丰富，更进一步的是angular2允许自定义管道。自定义一个管道需要以下两个步骤：
2.1、声明元数据
和实现一个组件类似，一个自定义的管道也是具有特定元数据的类，如
import {Component,Pipe} from "angular2/core"; @Pipe({name: "anyPipeName"}) class anyPipeNamePipe {...}
Pipe注解为被装饰的类附加了管道元数据，其最重要的属性是name，也就是我们在模板中调用这个管道时使用的名称。上面定义的管道，我们可以在模板中这样使用：
<p>{{ data | anyPipeName }}</p>
2.2 实现transform方法
定义一个自定义的管道必须实现一个预定的方法transform(input,args)，其中这个方法的input参数代表输入数据，args参数代表输入参数，返回值将被作为管道的输出。
import {Component,Pipe} from "angular2/core"; @Pipe({name: "anyPipeName"}) class anyPipeNamePipe { transform(input,args){ return ...; } }
通过以上定义一个自定义的管道，需要说明的是这样的一个pipe需要以下这样几个关键的点：
	•	管道是一个带有pipe元数据的类；
	•	这个类实现一个转换方法，通过一个输入值和一个可选的数组字符参数，最终返回转换后的值；
	•	数组参数中的某一项将每一个参数传递给pipe；
	•	我们通知Angular这是一个引入过Angular核心库的@Pipe服务
	•	这个@Pipe服务带有一个参数，该参数它的值是一个pipe名，我们将使用在一个模板表达式中，它可以是一个合法的Javascript定义。
	•	最后我们通过例子来说明自定义管道的使用，但是需要特别注意的是：
	•	在组件的模板中使用自定义管道之前，需要预先声明一下，即使用Component注解的pipes属性进行声明：pipes:[EzPipe]，以便Angular2注入。
	•	如果我们忽视去列出我们的自定义pipe，Angular2将会报错。我们不需要在先前的例子中列出内置指令是因为所有Angular2内置的pipes是预先注册过的，自定义的pipes必须手动注册。
	•	自定义管道完整的例子如下：
import {Component,Pipe} from "angular2/core"; import {bootstrap} from "angular2/platform/browser"; @Pipe({name:"title"}) class TitlePipe{ transform(input,args){ return input.split(" ") .map(word => word[0].toUpperCase() + word.slice(1)) .join(" "); } } @Component({ selector:"Demo-app", template:` <p>{{text | title}}</p> `, pipes : [TitlePipe] }) class DemoApp{ constructor(){ this.text = "what a wonderful world!"; } } bootstrap(DemoApp);
3.管道状态
3.1 无状态的管道
无状态的管道是一个纯粹的方法，流入的数据将不会记录任何东西，或者不会导致任何的副作用。大多数的管道是无状态的，例如我们之前例子的Datapipe就是一个无状态的pipe。据我们之前了解到的管道，包括angular2内置的管道，都具有这么一个特点，就是其输出仅仅是依赖于输入，这就是angular2中的无状态管道，对于无状态的管道，当视图组件的输入没有变化时，angular2框架是不会重新计算管道的输出的。
3.2 有状态的管道
有状态的管道在概念上类似于面向对象编程类，它们可以管理数据的变换，例如管道创建一个HTTP请求，存储它的返回和显示结果，就是一个有状态的pipe。需要注意的是，检索或请求数据的管道应该要谨慎使用，因为使用网路数据往往会引入错误的条件，在javascript中处理更优于在模板中处理。我们可以为了特定的后端和基本的异常捕获而创建自定义的pipe来减轻任何风险。
angular2对有状态的管道定义的关键在于使用使用Pipe注解的属性“pure”，并设置该属性的值为false即可，其作用是要求angular2框架在每个变化检查周期都执行管道的transform()方法。下面我们给一个例子，实现一个10到0的倒数计时器。
import {Component,Pipe} from "angular2/core"; import {bootstrap} from "angular2/platform/browser"; @Pipe({ name : "countdown", pure : false }) class CountdownPipe { transform(input){ this.initOnce(input); return this.counter; } initOnce(input){ this.counter = input; this.timer = setInterval(() => { this.counter--; if(this.counter === 0) clearInterval(this.timer); }, 1000); } } @Component({ selector:"demo-app", template:`<h1>this is a stateful pipe : {{ 10 | countdown }}</h1>`, pipes : [CountdownPipe] }) class DemoApp{} bootstrap(DemoApp);
从这个例子中可以看出，自定义管道countdownPipe的输出不仅依赖输出，还依赖与其内部的变化或者运行状态。
而angular2中，AsyncPipe是有状态管道的一个标志性的例子，AsyncPipe它的输入是一个异步对象：Promise对象、Observable对象或者EventEmitter对象，并且自动的订阅(subscrib)输入对象，最终每当异步对象产生新的值，AsyncPipe会返回这个新的值，它的有状态性是因为pipe维护一个输入的订阅并且它的返回值也依赖于这个订阅器。下面给出的例子，我们将用AsyncPipe绑定一个简单的promise给一个view。
import {Component} from 'angular2/core'; // Initial view: "Message: " // After 500ms: Message: You are my Hero!" @Component({ selector: 'hero-message', template: 'Message: {{delayedMessage | async}}', }) export class HeroAsyncMessageComponent { delayedMessage: Promise<string> = new Promise((resolve, reject) => { setTimeout(() => resolve('You are my Hero!'), 500); }); }
3.3 管道无状态和有状态的区别
管道的有状态和无状态的区别，关键在于是否是需要Angular2框架在输入不变的情况下依然持续地进行变化检测，而angular2的无状态的管道是依赖输入的，即同样的输入，总是产生同样的输出。举个例子，例如我们上面的管道，当我们输入一个默认的数字后，输出值依赖其内部的运行状态变化，而无状态的管道，例如一个加减乘除的管道，在Angular2中，它被视为无状态的，因为它的一次输入不会产生多次输出。
 
 
